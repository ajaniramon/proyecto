<?php
/**
 * Test class for IgepConexion.
 * Generated by PHPUnit on 2008-02-05 at 12:56:39.
 */
class IgepConexionTest extends PHPUnit_Framework_TestCase {

	// si cuando no pasa validacion, el metodo de transformacion devuelve false
	// pendiente de hacerlo a que esten todos los tests de esta clase y de configep
	private $valida = false;

    /**
     * Sets up the fixture, for example, opens a network connection.
     * This method is called before a test is executed.
     *
     * @access protected
     */
    protected function setUp() {
    }

    /**
     * Tears down the fixture, for example, closes a network connection.
     * This method is called after a test is executed.
     *
     * @access protected
     */
    protected function tearDown() {
    }

    /**
     * @todo Implement test_destruct().
     */
    public function test_destruct() {
        // Remove the following lines when you implement this test.
        $this->markTestIncomplete(
          'This test has not been implemented yet.'
        );
    }

    /**
     * @todo Implement testGetConexion().
     */
    public function testGetConexion() {
        // Remove the following lines when you implement this test.
        $this->markTestIncomplete(
          'This test has not been implemented yet.'
        );
    }

    /**
     * @todo Implement testGetDsn().
     */
    public function testGetDsn() {
        // Remove the following lines when you implement this test.
        $this->markTestIncomplete(
          'This test has not been implemented yet.'
        );
    }

    /**
     * @todo Implement testEmpezarTransaccion().
     */
    public function testEmpezarTransaccion() {
        // Remove the following lines when you implement this test.
        $this->markTestIncomplete(
          'This test has not been implemented yet.'
        );
    }

    /**
     * @todo Implement testAcabarTransaccion().
     */
    public function testAcabarTransaccion() {
        // Remove the following lines when you implement this test.
        $this->markTestIncomplete(
          'This test has not been implemented yet.'
        );
    }

    public function testConstruirWhere() {
    	$dbs = IgepDB::supportedDBMS();
    	foreach ($dbs as $db) {
    		$dsn_virtual = array('phptype'=>$db);
			$stub = $this->getMock('IgepConexion', array('conectar'), array($dsn_virtual), $db.'_MockIgepConexionCW',false);
			$stub->v_dsn = $dsn_virtual;

			$this->assertSame("",$stub->construirWhere(array(),''), $db);
			$this->assertSame("(a=b)",$stub->construirWhere(array(),'(a=b)'), $db);
			// con where inicial vacia
			$this->assertSame(" (c1='v1')",$stub->construirWhere(array('c1'=>'v1'),''), $db);
			$this->assertSame(" (c1=34)",$stub->construirWhere(array('c1'=>34),''), $db);
			// con where inicial (solo 1 caso, el resto igual)
			$this->assertSame(" a=b OR (c1='v1')",$stub->construirWhere(array('c1'=>'v1'),' a=b'), $db);
			// con 2 campos en array (solo 1 caso, el resto igual)
			$this->assertSame(" (c1='v1' AND c2='v2')",$stub->construirWhere(array('c1'=>'v1','c2'=>'v2'),''), $db);
 			// con 2 campos en array pero uno vacio (solo 1 caso, el resto igual)
			$this->assertSame(" (c1='v1' AND c2 is null)",$stub->construirWhere(array('c1'=>'v1','c2'=>''),''), $db);
			$this->assertSame(" (c1='v1' AND c2 is null)",$stub->construirWhere(array('c1'=>'v1','c2'=>0),''), $db);
			$this->assertSame(" (c1='v1' AND c2 is null)",$stub->construirWhere(array('c1'=>'v1','c2'=>null),''), $db);
    	}
    }

    public function testConstruirWhereConLike() {
    	$dbs = IgepDB::supportedDBMS();
    	foreach ($dbs as $db) {
    		$dsn_virtual = array('phptype'=>$db);
			$stub = $this->getMock('IgepConexion', array('conectar'), array($dsn_virtual), $db.'_MockIgepConexionCWCL',false);
			$stub->v_dsn = $dsn_virtual;
			
			$this->assertSame("",$stub->construirWhereConLike(array(),'',3), $db);
			$this->assertSame("(a=b)",$stub->construirWhereConLike(array(),'(a=b)',3), $db);
			// con where inicial vacia
			$this->assertSame(" (campo1='val1')",$stub->construirWhereConLike(array('campo1'=>'val1'),'',0), $db);
			$this->assertSame(" (".IgepDB::toTextForVS($dsn_virtual,"campo1")." LIKE '%val1%')",$stub->construirWhereConLike(array('campo1'=>'val1'),'',1), $db);
			$this->assertSame(" (campo1='val1')",$stub->construirWhereConLike(array('campo1'=>'val1'),'',2), $db);
			$this->assertSame(" (campo1=3)",$stub->construirWhereConLike(array('campo1'=>3),'',2), $db);
			$this->assertSame(" (".IgepDB::toTextForVS($dsn_virtual,"campo1")." LIKE 'val1%')",$stub->construirWhereConLike(array('campo1'=>'val1%'),'',2), $db);
			$this->assertSame(" (".IgepDB::toTextForVS($dsn_virtual,"campo1")." LIKE 'val_1')",$stub->construirWhereConLike(array('campo1'=>'val_1'),'',2), $db);
			$this->assertSame(" (campo1=34)",$stub->construirWhereConLike(array('campo1'=>34),'',2), $db);
			$this->assertSame(" (lower(".IgepDB::toTextForVS($dsn_virtual,"campo1").") LIKE ".IgepDB::unDiacritic($dsn_virtual,"lower('%val1%')").')',$stub->construirWhereConLike(array('campo1'=>'val1'),'',3), $db);
			// con where inicial (solo 1 caso, el resto igual)
			$this->assertSame("where a=b OR (".IgepDB::toTextForVS($dsn_virtual,"campo1")." LIKE '%val1%')",$stub->construirWhereConLike(array('campo1'=>'val1'),'where a=b',1), $db);
			// con 2 campos en array (solo 1 caso, el resto igual)
			$this->assertSame(" (".IgepDB::toTextForVS($dsn_virtual,"c1")." LIKE '%v1%' AND ".IgepDB::toTextForVS($dsn_virtual,"c2")." LIKE '%v2%')",$stub->construirWhereConLike(array('c1'=>'v1','c2'=>'v2'),'',1), $db);
			// con 2 campos en array pero uno vacio (solo 1 caso, el resto igual)
			$this->assertSame(" (".IgepDB::toTextForVS($dsn_virtual,"c1")." LIKE '%v1%')",$stub->construirWhereConLike(array('c1'=>'v1','c2'=>''),'',1), $db);
    	}
    }

    /**
     * @todo Implement testCombinarWhere().
     */
    public function testCombinarWhere() {
        // Remove the following lines when you implement this test.
        $this->markTestIncomplete(
          'This test has not been implemented yet.'
        );
    }

    /**
     * @todo Implement testConstruirLimite().
     */
    public function testConstruirLimite() {
        // Remove the following lines when you implement this test.
        $this->markTestIncomplete(
          'This test has not been implemented yet.'
        );
    }

    /**
     * @todo Implement testConsultar().
     */
    public function testConsultar() {
        // Remove the following lines when you implement this test.
        $this->markTestIncomplete(
          'This test has not been implemented yet.'
        );
    }

    /**
     * @todo Implement testOperar().
     */
    public function testOperar() {
        // Remove the following lines when you implement this test.
        $this->markTestIncomplete(
          'This test has not been implemented yet.'
        );
    }


    /**
     * de negocio a bd
     */
    public function testPrepararOperacion() {
    	$dbs = IgepDB::supportedDBMS();
    	$n = ConfigFramework::getNumericSeparatorsFW();
   		$nd = $n['DECIMAL'];
   		$ng = $n['GROUP'];
   		$nf = ConfigFramework::getDateMaskFW();
   		$fhora = ' H:i:s';
    	foreach ($dbs as $db) {
    		$dsn_virtual = array('phptype'=>$db);
			$stub = $this->getMock('IgepConexion', array('conectar'), array($dsn_virtual), $db.'_MockIgepConexion',false);
			$stub->v_dsn = $dsn_virtual;
			$backslash = IgepDB::backSlashScape($dsn_virtual);

    		$d = IgepDB::caracteresNumericos($dsn_virtual);
    		$dd = $d['DECIMAL'];
    		$dg = $d['GROUP'];
    		$df = IgepDB::mascaraFechas($dsn_virtual);

			// sin tipo -> cadenas
			$v="abc";
			$stub->prepararOperacion($v);
			$this->assertEquals("abc",$v, $db.': prepararOperacion- conversion de cadena');

			$v="a'bc";
			$stub->prepararOperacion($v);
			$this->assertEquals("a''bc",$v, $db.': prepararOperacion- conversion de cadena con comilla simple');
			
			$v='a"bc';
			$stub->prepararOperacion($v);
			$this->assertEquals('a"bc',$v, $db.': prepararOperacion- conversion de cadena con comilla doble - escapando');

			$v="a\\bc";
			$stub->prepararOperacion($v);
			$this->assertEquals("a{$backslash}bc",$v, $db.': prepararOperacion- conversion de cadena con barra invertida y sin tipo');

			// con tipo null -> cadenas
			$v="abc";
			$stub->prepararOperacion($v,null);
			$this->assertEquals("abc",$v, $db.': prepararOperacion- conversion de cadena');

			$v="a'bc";
			$stub->prepararOperacion($v,null);
			$this->assertEquals("a''bc",$v, $db.': prepararOperacion- conversion de cadena con comilla simple');
			
			$v='a"bc';
			$stub->prepararOperacion($v,null);
			$this->assertEquals('a"bc',$v, $db.': prepararOperacion- conversion de cadena con comilla doble - escapando');

			$v="a\\bc";
			$stub->prepararOperacion($v,null);
			$this->assertEquals("a{$backslash}bc",$v, $db.': prepararOperacion- conversion de cadena con barra invertida y con tipo null');

			// cadenas
			$v="abc";
			$stub->prepararOperacion($v,TIPO_CARACTER);
			$this->assertEquals("abc",$v, $db.': prepararOperacion- conversion de cadena');

			$v="a'bc";
			$stub->prepararOperacion($v,TIPO_CARACTER);
			$this->assertEquals("a''bc",$v, $db.': prepararOperacion- conversion de cadena con comilla simple');
			
			$v='a"bc';
			$stub->prepararOperacion($v,TIPO_CARACTER);
			$this->assertEquals('a"bc',$v, $db.': prepararOperacion- conversion de cadena con comilla doble - escapando');

			$v="a\\bc";
			$stub->prepararOperacion($v,TIPO_CARACTER);
			$this->assertEquals("a{$backslash}bc",$v, $db.': prepararOperacion- conversion de cadena con barra invertida con tipo caracter');

			// numeros
			$v="1{$ng}234{$ng}567{$nd}8";
			$stub->prepararOperacion($v,TIPO_DECIMAL);
			$this->assertEquals("1{$dg}234{$dg}567{$dd}8",$v, $db.': prepararOperacion- conversion de numero con grupos y decimales (1) a bd');
			$v="1{$ng}234{$ng}567{$nd}89";
			$stub->prepararOperacion($v,TIPO_DECIMAL);
			$this->assertEquals("1{$dg}234{$dg}567{$dd}89",$v, $db.': prepararOperacion- conversion de numero con grupos y decimales (2) a bd');
			$v="0";
			$stub->prepararOperacion($v,TIPO_DECIMAL);
			$this->assertEquals("0", $v, $db.': prepararOperacion- conversion de numero 0 en cadena');
			$v=0;
			$stub->prepararOperacion($v,TIPO_DECIMAL);
			$this->assertEquals("0", $v, $db.': prepararOperacion- conversion de numero 0 en numero');
			$v="1e5";
			$stub->prepararOperacion($v,TIPO_DECIMAL);
			$this->assertSame("100{$dg}000", $v, $db.': prepararOperacion- conversion de numero con exponente a bd');
			$v="1e-5";
			$stub->prepararOperacion($v,TIPO_DECIMAL);
			$this->assertSame("0{$dd}00001", $v, $db.': prepararOperacion- conversion de numero con exponente negativo a bd');
			$v="1e5";
			$stub->prepararOperacion($v,TIPO_ENTERO);
			$this->assertSame("100{$dg}000", $v, $db.': prepararOperacion- conversion de numero entero con exponente a bd');

			$v="-1{$ng}234{$ng}567{$nd}8";
			$stub->prepararOperacion($v,TIPO_DECIMAL);
			$this->assertEquals("-1{$dg}234{$dg}567{$dd}8", $v, $db.': prepararOperacion- conversion de numero con signo - a bd');
			$v="+1{$ng}234{$ng}567{$nd}8";
			$stub->prepararOperacion($v,TIPO_DECIMAL);
			$this->assertEquals("1{$dg}234{$dg}567{$dd}8", $v, $db.': prepararOperacion- conversion de numero con signo + a bd');

			$v="";
			$stub->prepararOperacion($v,TIPO_ENTERO);
			$this->assertEquals("", $v, $db.': prepararOperacion- conversion de numero con cadena vacia');
			$v=null;
			$stub->prepararOperacion($v,TIPO_ENTERO);
			$this->assertTrue(is_null($v), $db.': prepararOperacion- conversion de numero con null');

			// fechas
			$fnegocio = new gvHidraTimestamp('1995-12-24');
			$fespe = $fnegocio->format($df);
			$fbd = $fnegocio;
			$stub->prepararOperacion($fbd,TIPO_FECHA);
			$this->assertEquals($fbd, $fespe, $db.': fecha obj sin hora');
			$fbd = $fnegocio->formatFW();
			$stub->prepararOperacion($fbd,TIPO_FECHA);
			$this->assertEquals($fbd, $fespe, $db.': fecha txt sin hora '.$fbd);
			
			$fnegocio = new gvHidraTimestamp('1995-12-24 18:34:56');
			$fbd = $fnegocio;
			$stub->prepararOperacion($fbd,TIPO_FECHAHORA);
			$this->assertEquals($fbd, $fnegocio->format($df.$fhora), $db.': fecha obj con hora');
			$fbd = $fnegocio->formatFW();
			$stub->prepararOperacion($fbd,TIPO_FECHAHORA);
			$this->assertEquals($fbd, $fnegocio->format($df.$fhora), $db.': fecha txt con hora');

			$fnegocio = null;
			$fbd = $fnegocio; 
			$stub->prepararOperacion($fbd,TIPO_FECHAHORA);
			$this->assertSame($fbd, $fnegocio, $db.': fecha nula');

			// repito las operaciones anteriores pero ahora dentro de un array
			$datos = array(
				array('edad'=>"1e5", 'importe'=>"1{$ng}234{$ng}567{$nd}8", 'nom'=>"abc", 'saldo'=>"-12", 'ffirma'=>new gvHidraTimestamp('1995-12-24'), 'nombre'=>"abc", ),
				array('edad'=>"-1{$ng}234{$ng}567", 'importe'=>"1{$ng}234{$ng}567{$nd}89", 'nom'=>"", 'saldo'=>"+12", 'ffirma'=>"se asigna abajo!!!", 'nombre'=>"a'bc", ),
				array('edad'=>"+1{$ng}234{$ng}567", 'importe'=>"0", 'nom'=>"", 'saldo'=>"", 'factu'=>new gvHidraTimestamp('1995-12-24 18:34:56'), 'nombre'=>'a"bc', ),
				array('edad'=>"", 'importe'=>0, 'nom'=>"", 'saldo'=>"", 'factu'=>"se asigna abajo!!!", 'nombre'=>"a\\bc", ),
				array('edad'=>null, 'importe'=>"1e5", 'nom'=>"", 'saldo'=>"", 'factu'=>null, 'nombre'=>"a'bc", ),
				array('edad'=>"", 'importe'=>"1e-5", 'nom'=>"", 'saldo'=>"", 'nombre'=>'a"bc', ),
				array('nombre'=>"a\\bc", 'otroTexto'=>"a'bc",),
				);
			$datos[1]['ffirma'] = $datos[0]['ffirma']->format($nf);
			$datos[3]['factu'] = $datos[2]['factu']->format($nf.$fhora);
			$tipos = array('edad'=>array('tipo'=>TIPO_ENTERO),
							'importe'=>array('tipo'=>TIPO_DECIMAL, 'parteDecimal'=>2),
							'saldo'=>array('tipo'=>TIPO_ENTERO),
							'ffirma'=>array('tipo'=>TIPO_FECHA),
							'factu'=>array('tipo'=>TIPO_FECHAHORA),
							'nombre'=>array('tipo'=>TIPO_CARACTER),
					);
			$valor = $datos;
    		$stub->prepararOperacion($valor,$tipos);

			// cadenas
			$this->assertEquals($valor[0]['nombre'],"abc", $db.': prepararOperacion- conversion de cadena (array)');
			$this->assertEquals($valor[1]['nombre'],"a''bc", $db.': prepararOperacion- conversion de cadena con comilla simple (array)');
			$this->assertEquals($valor[2]['nombre'],'a"bc', $db.': prepararOperacion- conversion de cadena con comilla doble - escapando (array)');
			$this->assertEquals($valor[3]['nombre'],"a{$backslash}bc", $db.': prepararOperacion- conversion de cadena con barra invertida (array)');
			$this->assertEquals($valor[6]['otroTexto'],"a''bc", $db.': prepararOperacion- conversion de cadena sin definir con comilla simple (array)');

			// numeros
			$this->assertEquals($valor[0]['importe'],"1{$dg}234{$dg}567{$dd}8", $db.': prepararOperacion- conversion de numero con grupos y decimales (1) a bd (array)');
			$this->assertEquals($valor[1]['importe'],"1{$dg}234{$dg}567{$dd}89", $db.': prepararOperacion- conversion de numero con grupos y decimales (2) a bd (array)');
			$this->assertEquals($valor[2]['importe'],"0", $db.': prepararOperacion- conversion de numero 0 en cadena (array)');
			$this->assertEquals($valor[3]['importe'],"0", $db.': prepararOperacion- conversion de numero 0 en numero (array)');
			$this->assertSame($valor[4]['importe'],"100{$dg}000", $db.': prepararOperacion- conversion de numero con exponente a bd (array)');
			$this->assertSame($valor[5]['importe'],"0{$dd}00001", $db.': prepararOperacion- conversion de numero con exponente negativo a bd (array)');
			$this->assertSame($valor[0]['edad'],"100{$dg}000", $db.': prepararOperacion- conversion de numero entero con exponente a bd (array)');
			$this->assertEquals($valor[1]['edad'],"-1{$dg}234{$dg}567", $db.': prepararOperacion- conversion de numero con signo - a bd (array)');
			$this->assertEquals($valor[2]['edad'],"1{$dg}234{$dg}567", $db.': prepararOperacion- conversion de numero con signo + a bd (array)');
			$this->assertEquals($valor[3]['edad'],"", $db.': prepararOperacion- conversion de numero con cadena vacia (array)');
			$this->assertTrue(is_null($valor[4]['edad']), $db.': prepararOperacion- conversion de numero con null (array)');

			// fechas
			$this->assertEquals($valor[0]['ffirma'], $datos[0]['ffirma']->format($df), $db.': fecha obj sin hora (array)');
			$this->assertEquals($valor[1]['ffirma'], $datos[0]['ffirma']->format($df), $db.': fecha txt sin hora (array)');
			$this->assertEquals($valor[2]['factu'], $datos[2]['factu']->format($df.$fhora), $db.': fecha obj con hora (array)');
			$this->assertEquals($valor[3]['factu'], $datos[2]['factu']->format($df.$fhora), $db.': fecha txt con hora (array)');
			$this->assertSame($valor[4]['factu'], $datos[4]['factu'], $db.': fecha null (array)');
    	}
    }


// ANTIGUOS TEST, CUANDO ESTE METODO CONVERTIA DE INTERFAZ A BD
//    /**
//     * de presentacion a bd
//     */
//    public function testPrepararOperacion() {
//		$dbs = IgepDB::supportedDBMS();
//        $p = ConfigFramework::getNumericSeparatorsUser();
//        $pd = $p['DECIMAL'];
//        $pg = $p['GROUP'];
//		foreach ($dbs as $db) {
//			$dsn_virtual = array('phptype'=>$db);
//	        $stub = $this->getMock('IgepConexion', array('conectar'), array($dsn_virtual), $db.'_MockIgepConexion',false);
//			$stub->v_dsn = $dsn_virtual;
//	        $c = IgepDB::caracteresNumericos($dsn_virtual);
//	        $d = $c['DECIMAL'];
//	        $g = $c['GROUP'];
//
//	        $datos = "1{$pg}234{$pg}567{$pd}8";
//	        $stub->prepararOperacion($datos,TIPO_DECIMAL);
//			$this->assertEquals("1{$g}234{$g}567{$d}8",$datos,$db.': conversion de numero con grupos y decimales (1) a bd');
//
//			$datos = "1{$pg}234{$pg}567{$pd}89";
//			$stub->prepararOperacion($datos,TIPO_DECIMAL);
//			$this->assertEquals("1{$g}234{$g}567{$d}89",$datos,$db.': conversion de numero con grupos y decimales (2) a bd');
//
//			$datos = "1{$pg}234{$pg}567{$pd}890123450";
//			$stub->prepararOperacion($datos,TIPO_DECIMAL);
//			$this->assertEquals("1{$g}234{$g}567{$d}890123450",$datos,$db.': conversion de numero con grupos y decimales (muchos) a bd');
//
//			$datos = "0";
//			$stub->prepararOperacion($datos,TIPO_DECIMAL);
//			$this->assertEquals("0",$datos,$db.': conversion de numero 0 en cadena');
//
//			$datos = 0;
//			$stub->prepararOperacion($datos,TIPO_DECIMAL);
//			$this->assertTrue(0===$datos,$db.': conversion de numero 0 en numero');
//
//			$datos = "aaa";
//			$stub->prepararOperacion($datos,TIPO_DECIMAL);
//			if ($this->valida)
//				$this->assertTrue(false===$datos,$db.': conversion de numero invalido');
//			else
//				$this->assertEquals(0,$datos,$db.': conversion de numero invalido');
//			$errores = ConfigFramework::getTransformErrors();
//			$this->assertEquals(1, count($errores), 'no defecta numero invalido - '.var_export($errores,true));
//
//	        $datos = "1{$pg}234{$pg}567";
//	        $stub->prepararOperacion($datos,TIPO_ENTERO);
//			$this->assertEquals("1{$g}234{$g}567",$datos,$db.': conversion de entero con grupos');
//
//	        $datos = "1{$pg}2{$pg}{$pg}34{$pg}567";
//	        $stub->prepararOperacion($datos,TIPO_ENTERO);
//			$this->assertEquals("1{$g}234{$g}567",$datos,$db.': conversion de entero con grupos mal puestos');
//
//	        $datos = "1567";
//	        $stub->prepararOperacion($datos,TIPO_ENTERO);
//			$this->assertEquals("1{$g}567",$datos,$db.': conversion de entero introducido sin grupos');
//
//	        $datos = "567";
//	        $stub->prepararOperacion($datos,TIPO_ENTERO);
//			$this->assertEquals("567",$datos,$db.': conversion de entero sin grupos');
//
//	        $datos = "0";
//	        $stub->prepararOperacion($datos,TIPO_ENTERO);
//			$this->assertEquals("0",$datos,$db.': conversion de entero 0 en cadena');
//
//	        $datos = 0;
//	        $stub->prepararOperacion($datos,TIPO_ENTERO);
//			$this->assertEquals("0",$datos,$db.': conversion de entero 0 en numero');
//
//	        $datos = "-567";
//	        $stub->prepararOperacion($datos,TIPO_ENTERO);
//			$this->assertEquals("-567",$datos,$db.': conversion de entero con signo -');
//
//	        $datos = "+567";
//	        $stub->prepararOperacion($datos,TIPO_ENTERO);
//			$this->assertEquals("567",$datos,$db.': conversion de entero con signo +');
//
//	        $datos = "567";
//	        $stub->prepararOperacion($datos,TIPO_CARACTER);
//			$this->assertEquals("567",$datos,$db.': convirtiendo texto sin caracteres especiales');
//
//	        $datos = "5'67";
//	        $stub->prepararOperacion($datos,TIPO_CARACTER);
//			$this->assertEquals("5''67",$datos,$db.': convirtiendo texto con comilla simple');
//
//	        $datos = '56"7';
//	        $stub->prepararOperacion($datos,TIPO_CARACTER);
//			$this->assertEquals('56"7',$datos,$db.': convirtiendo texto con comilla doble');
//
//	        $datos = "5\\67";//
//	        $stub->prepararOperacion($datos,TIPO_CARACTER);
//			$this->assertEquals("5\\\\67",$datos,$db.': convirtiendo texto con barra invertida');
//
//			$datos = "aaa";
//			$stub->prepararOperacion($datos,TIPO_FECHA);
//			if ($this->valida)
//				$this->assertTrue(false===$datos,$db.': conversion de fecha invalida');
//			else
//				$this->assertNotEquals('-',$datos,$db.': conversion de fecha invalida');
//			$errores = ConfigFramework::getTransformErrors();
//			$this->assertEquals(1, count($errores), 'no defecta fecha invalida - '.var_export($errores,true));
//
//			// repito las operaciones anteriores pero ahora dentro de un array
//			// como el destino es bd no hace falta indicar decimales en array tipos
//			$datos_orig = array(
//				array('edad'=>"1{$pg}234{$pg}567", 'importe'=>"1{$pg}234{$pg}567{$pd}8", 'nom'=>"567", 'saldo'=>"-567",),
//				array('edad'=>"1{$pg}2{$pg}{$pg}34{$pg}567",'importe'=>"1{$pg}234{$pg}567{$pd}89", 'nom'=>"5'67", 'saldo'=>"+567",),
//				array('edad'=>'1567','importe'=>"1{$pg}234{$pg}567{$pd}890123450", 'nom'=>'56"7',),
//				array('edad'=>'567', 'nom'=>"5\\67",),
//				array('edad'=>'0','importe'=>"0",),
//				array('edad'=>0,'importe'=>0,),
//				);
//			$datos = $datos_orig;
//			$tipos = array('edad'=>array('tipo'=>TIPO_ENTERO), 'importe'=>array('tipo'=>TIPO_DECIMAL), 'saldo'=>array('tipo'=>TIPO_ENTERO),);
//	        $stub->prepararOperacion($datos,$tipos);
//
//			$this->assertEquals("1{$g}234{$g}567{$d}8",$datos[0]['importe'],$db.': conversion de numero con grupos y decimales (1) a bd (array)');
//			$this->assertEquals("1{$g}234{$g}567{$d}89",$datos[1]['importe'],$db.': conversion de numero con grupos y decimales (2) a bd (array)');
//			$this->assertEquals("1{$g}234{$g}567{$d}890123450",$datos[2]['importe'],$db.': conversion de numero con grupos y decimales (muchos) a bd (array)');
//			$this->assertEquals("0",$datos[4]['importe'],$db.': conversion de numero 0 en cadena (array)');
//			$this->assertEquals("0",$datos[5]['importe'],$db.': conversion de numero 0 en numero (array)');
//
//			$this->assertEquals("1{$g}234{$g}567",$datos[0]['edad'],$db.': conversion de entero con grupos (array)');
//			$this->assertEquals("1{$g}234{$g}567",$datos[1]['edad'],$db.': conversion de entero con grupos mal puestos (array)');
//			$this->assertEquals("1{$g}567",$datos[2]['edad'],$db.': conversion de entero introducido sin grupos (array)');
//			$this->assertEquals("567",$datos[3]['edad'],$db.': conversion de entero sin grupos (array)');
//			$this->assertEquals("0",$datos[4]['edad'],$db.': conversion de entero 0 en cadena (array)');
//			$this->assertEquals("0",$datos[5]['edad'],$db.': conversion de entero 0 en numero (array)');
//			$this->assertEquals("-567",$datos[0]['saldo'],$db.': conversion de entero con signo - (array)');
//			$this->assertEquals( "567",$datos[1]['saldo'],$db.': conversion de entero con signo + (array)');
//
//			$this->assertEquals("567",$datos[0]['nom'],$db.': convirtiendo texto (sin tipo) sin caracteres especiales (array)');
//			$this->assertEquals("5''67",$datos[1]['nom'],$db.': convirtiendo texto (sin tipo) con comilla simple (array)');
//			$this->assertEquals('56"7',$datos[2]['nom'],$db.': convirtiendo texto (sin tipo) con comilla doble (array)');
//			$this->assertEquals("5\\\\67",$datos[3]['nom'],$db.': convirtiendo texto (sin tipo) con barra invertida (array)');
//
//			$tipos = array('nom'=>array('tipo'=>TIPO_CARACTER),);
//			$datos = $datos_orig;
//	        $stub->prepararOperacion($datos,$tipos);
//			$this->assertEquals("567",$datos[0]['nom'],$db.': convirtiendo texto (con tipo) sin caracteres especiales (array)');
//			$this->assertEquals("5''67",$datos[1]['nom'],$db.': convirtiendo texto (con tipo) con comilla simple (array)');
//			$this->assertEquals('56"7',$datos[2]['nom'],$db.': convirtiendo texto (con tipo) con comilla doble (array)');
//			$this->assertEquals("5\\\\67",$datos[3]['nom'],$db.': convirtiendo texto (con tipo) con barra invertida (array)');
//
//			//TO DO: testear fechas
//
//			$stub = null;
//		}
//    }

    /**
     * de negocio a bd
     */
    public function testPrepararNumero() {
		$dbs = IgepDB::supportedDBMS();
        $n = ConfigFramework::getNumericSeparatorsFW();
        $nd = $n['DECIMAL'];
        $ng = $n['GROUP'];
		foreach ($dbs as $db) {
			$dsn_virtual = array('phptype'=>$db);
	        $stub = $this->getMock('IgepConexion', array('conectar'), array($dsn_virtual), $db.'_testPrepararNumero_MockIgepConexion',false);
			$stub->v_dsn = $dsn_virtual;
	        $d = IgepDB::caracteresNumericos($dsn_virtual);
	        $dd = $d['DECIMAL'];
	        $dg = $d['GROUP'];

			// los tests completos en IgepConexion::prepararOperacion
			$this->assertEquals("1{$dg}234{$dg}567{$dd}8",$stub->prepararNumero("1{$ng}234{$ng}567{$nd}8"),$db.': prepararNumero- conversion de numero con grupos y decimales (1) a bd');

			$stub = null;
	    }
    }

    /**
     * de negocio a bd
     */
    public function testPrepararFecha() {
		$dbs = IgepDB::supportedDBMS();
        $n = ConfigFramework::getDateMaskFW();
   		$fhora = ' H:i:s';
		foreach ($dbs as $db) {
			$dsn_virtual = array('phptype'=>$db);
	        $stub = $this->getMock('IgepConexion', array('conectar'), array($dsn_virtual), $db.'_testPrepararFecha_MockIgepConexion',false);
			$stub->v_dsn = $dsn_virtual;
	        $d = IgepDB::mascaraFechas($dsn_virtual);

			// los mismos que en IgepConexion::prepararOperacion para fechas
			$fnegocio = new gvHidraTimestamp('1995-12-24');
			$fbd = $stub->prepararFecha($fnegocio);
			$this->assertSame($fbd, $fnegocio->format($d.$fhora), $db.': fecha num sin hora');
			$fbd = $stub->prepararFecha($fnegocio->format($n));
			$this->assertSame($fbd, $fnegocio->format($d), $db.': fecha txt sin hora');

			$fnegocio = new gvHidraTimestamp('1995-12-24 18:34:56');
			$fbd = $stub->prepararFecha($fnegocio);
			$this->assertSame($fbd, $fnegocio->format($d.$fhora), $db.': fecha num con hora');
			$fbd = $stub->prepararFecha($fnegocio->format($n.$fhora));
			$this->assertSame($fbd, $fnegocio->format($d.$fhora), $db.': fecha txt con hora');

			$stub = null;
	    }
    }

    /**
     * de bd a negocio
     */
    public function testTransform_BD2FW() {
    	$dbs = IgepDB::supportedDBMS();
    	$n = ConfigFramework::getNumericSeparatorsFW();
   		$nd = $n['DECIMAL'];
   		$ng = $n['GROUP'];
    	$fn = ConfigFramework::getDateMaskFW();
//    	// en formatos destino, siempre cambiamos n por m, y j por d
//  		$fn = str_replace('j', 'd', $fn);
//  		$fn = str_replace('n', 'm', $fn);
    	foreach ($dbs as $db) {
    		$dsn_virtual = array('phptype'=>$db);
    		$b = IgepDB::caracteresNumericos($dsn_virtual);
    		$bd = $b['DECIMAL'];
    		$bg = $b['GROUP'];
	        $stub = $this->getMock('IgepConexion', array('conectar'), array($dsn_virtual), $db.'_testTransform_BD2FW_MockIgepConexion',false);
			$stub->v_dsn = $dsn_virtual;
    		$f = IgepDB::mascaraFechas($dsn_virtual);

			$v = "12{$bg}345{$bd}56";
    		$stub->transform_BD2FW($v,TIPO_DECIMAL);
			$this->assertEquals($v, "12{$ng}345{$nd}56", $db.": convirtiendo numero");

			$v = "12{$bg}345{$bd}561000";
			$stub->transform_BD2FW($v,TIPO_DECIMAL);
			$this->assertSame($v, "12{$ng}345{$nd}561000", $db.": convirtiendo numero con 3 decimales y ceros al final");
			$this->assertEquals($v, "12{$ng}345{$nd}561", $db.": convirtiendo numero con 3 decimales sin ceros al final");

			$v = "12{$bg}345";
    		$stub->transform_BD2FW($v,TIPO_DECIMAL);
			$this->assertEquals($v, "12{$ng}345", $db.": convirtiendo numero sin decimales");

			$v = "12{$bg}345";
    		$stub->transform_BD2FW($v,TIPO_ENTERO,$dsn_virtual);
			$this->assertEquals($v, "12{$ng}345", $db.": convirtiendo numero entero");

			$v = "12";
    		$stub->transform_BD2FW($v,TIPO_ENTERO);
			$this->assertEquals($v, "12", $db.": convirtiendo numero entero sin grupos");

			$v = "-12";
    		$stub->transform_BD2FW($v,TIPO_ENTERO);
			$this->assertEquals($v, "-12", $db.": convirtiendo numero entero con signo -");

			$v = "+12";
    		$stub->transform_BD2FW($v,TIPO_ENTERO);
			$this->assertEquals($v, "12", $db.": convirtiendo numero entero con signo +");

			$v = "12";
    		$stub->transform_BD2FW($v,TIPO_CARACTER);
			$this->assertEquals($v, "12", $db.": convirtiendo texto sin caracteres especiales");

			$v = "1'2";
    		$stub->transform_BD2FW($v,TIPO_CARACTER);
			$this->assertEquals($v, "1'2", $db.": convirtiendo texto con comilla simple");

			$v = '1"2';
    		$stub->transform_BD2FW($v,TIPO_CARACTER);
			$this->assertEquals($v, '1"2', $db.": convirtiendo texto con comilla doble");

			$v = '1\2';
    		$stub->transform_BD2FW($v,TIPO_CARACTER);
			$this->assertEquals($v, '1\2', $db.": convirtiendo texto con barra invertida");

			// repito las operaciones anteriores pero ahora dentro de un array
			// en los decimales no afecta la longitud de decimales
			$datos = array(
				array('edad'=>"12{$bg}345", 'importe'=>"12{$bg}345{$bd}56", 'nom'=>"12", 'saldo'=>"-12",'cumple'=>'cambia en bucle'),
				array('edad'=>"12", 'importe'=>"12{$bg}345{$bd}561000", 'nom'=>"1'2", 'saldo'=>"+12",),
				array('edad'=>"", 'importe'=>"12{$bg}345", 'nom'=>'1"2',),
				array('edad'=>"", 'importe'=>"", 'nom'=>'1\2',),
				);
			$tipos = array('edad'=>array('tipo'=>TIPO_ENTERO), 'importe'=>array('tipo'=>TIPO_DECIMAL), 'saldo'=>array('tipo'=>TIPO_ENTERO),);
			$valor = $datos;
    		$stub->transform_BD2FW($valor,$tipos);
			$this->assertEquals($valor[0]['importe'], "12{$ng}345{$nd}56", $db.": convirtiendo numero (array)");
			$this->assertEquals($valor[1]['importe'], "12{$ng}345{$nd}561000", $db.": convirtiendo numero con 3 decimales y ceros al final (array)");
			$this->assertEquals($valor[1]['importe'], "12{$ng}345{$nd}561", $db.": convirtiendo numero con 3 decimales sin ceros al final (array)");
			$this->assertEquals($valor[2]['importe'], "12{$ng}345", $db.": convirtiendo numero sin decimales (array)");
			$this->assertEquals($valor[0]['edad'], "12{$ng}345", $db.": convirtiendo numero entero (array)");
			$this->assertEquals($valor[1]['edad'], "12", $db.": convirtiendo numero entero sin grupos (array)");
			$this->assertEquals($valor[0]['saldo'], "-12", $db.": convirtiendo numero entero con signo - (array)");
			$this->assertEquals($valor[1]['saldo'], "12", $db.": convirtiendo numero entero con signo + (array)");
			$this->assertEquals($valor[0]['nom'], "12", $db.": convirtiendo texto (sin tipo) sin caracteres especiales (array)");
			$this->assertEquals($valor[1]['nom'], "1'2", $db.": convirtiendo texto (sin tipo) con comilla simple (array)");
			$this->assertEquals($valor[2]['nom'], '1"2', $db.": convirtiendo texto (sin tipo) con comilla doble (array)");
			$this->assertEquals($valor[3]['nom'], '1\2', $db.": convirtiendo texto (sin tipo) con barra invertida (array)");
			$tipos = array('nom'=>array('tipo'=>TIPO_CARACTER,),);
			$valor = $datos;
    		$stub->transform_BD2FW($valor,$tipos);
			$this->assertEquals($valor[0]['nom'], "12", $db.": convirtiendo texto (con tipo) sin caracteres especiales (array)");
			$this->assertEquals($valor[1]['nom'], "1'2", $db.": convirtiendo texto (con tipo) con comilla simple (array)");
			$this->assertEquals($valor[2]['nom'], '1"2', $db.": convirtiendo texto (con tipo) con comilla doble (array)");
			$this->assertEquals($valor[3]['nom'], '1\2', $db.": convirtiendo texto (con tipo) con barra invertida (array)");

			// fechas individuales y array
			$v = '';
			$valor = $v;
    		$stub->transform_BD2FW($valor,TIPO_FECHAHORA);
			$this->assertSame($valor, null, $db.": convirtiendo fecha-hora vacia");

			$v = null;
			$valor = $v;
    		$stub->transform_BD2FW($valor,TIPO_FECHAHORA);
			$this->assertSame($valor,null, $db.": convirtiendo fecha-hora nula");

			$fechas = array(
				array(0, 0, 0, 4, 15, 1990,": convirtiendo fecha correcta",),
				array(0, 0, 0, 4, 15, 1960,": convirtiendo fecha anterior epoca unix",),
				array(0, 0, 0, 4, 15, 1919,": convirtiendo fecha de principios del siglo 20",),
				array(0, 0, 0, 4, 15, 1137,": convirtiendo fecha de la epoca de Jaume I",),
				array(0, 0, 0, 4, 15, 345,": convirtiendo fecha de anyo de 3",),
				array(0, 0, 0, 4, 15, 2040,": convirtiendo fecha posterior a epoca unix",),
				array(0, 0, 0, 4, 15, 9999,": convirtiendo fecha con año maximo",),
				// tratamiento especial de los años de 2: ventana
				array(0, 0, 0, 4, 15, 85,": convirtiendo fecha de anyo de 2 de epoca unix",),
				array(0, 0, 0, 4, 15, 34,": convirtiendo fecha de anyo de 2 fuera de epoca",),
				// tratamiento especial de los años de 1: coge la decada actual
				array(0, 0, 0, 4, 15, 3,": convirtiendo fecha de anyo de 1",),
				array(10, 20, 30, 4, 15, 2003,": convirtiendo fecha con hora",),
				array(1, 1, 1, 4, 15, 2003,": convirtiendo fecha con hora inicio dia",),
				array(23, 59, 58, 4, 15, 2003,": convirtiendo fecha con hora fin dia",),
				array(47, 0, 0, 4, 15, 2003,": convirtiendo fecha con hora y más de 24 horas",),
				array(0, 300, 0, 4, 15, 2003,": convirtiendo fecha con hora y más de 60 minutos",),
				array(0, 0, 3600, 4, 15, 2003,": convirtiendo fecha con hora y más de 60 segundos",),
				array(12, 34, 56, 14, 1, 2003,": convirtiendo fecha con hora y más de 12 meses",),
				array(12, 34, 56, 5, 40, 2003,": convirtiendo fecha con hora y más de 30 dias (hasta el 40 de mayo...)",),
				);

			foreach ($fechas as $fecha) {
				$anyo = $fecha[5];
	    		if ($anyo > 9 and $anyo < 100)
	    			$anyo += ($fecha[5]<=69)? 2000: 1900;
	    		elseif ($anyo <= 9)
	    			$anyo = (int) substr(date('Y'),0,3).((string)$anyo);
				$dt = new DateTime();
				$dt->setDate($anyo,$fecha[3],$fecha[4]);
				$dt->setTime($fecha[0],$fecha[1],$fecha[2]);
				$fhora = (($fecha[0] or $fecha[1] or $fecha[2])? ' H:i:s':'');

				// valor simple como fechahora
				$valor = $dt->format($f.$fhora);
	    		$stub->transform_BD2FW($valor,TIPO_FECHAHORA);
				$this->assertEquals($valor->formatFW(), $dt->format($fn.$fhora), $db.$fecha[6].' (valor simple como fechahora)');

				// valor simple como fecha
				// no valida si hay hora
				$valor = $dt->format($f.$fhora);
	    		$stub->transform_BD2FW($valor,TIPO_FECHA);
				$this->assertEquals($valor->formatFW(), $dt->format($fn), $db.$fecha[6].' (valor simple como fecha)');

				// valor como array fechahora
				$valor = $datos;
				$valor[0]['cumple']= $dt->format($f.$fhora);
	    		$stub->transform_BD2FW($valor, array('cumple'=>array('tipo'=>TIPO_FECHAHORA)));
				$this->assertEquals($valor[0]['cumple']->formatFW(), $dt->format($fn.$fhora), $db.$fecha[6].' (array con fechahora)');

				// valor como array fecha
				// no valida si hay hora
				$valor = $datos;
				$valor[0]['cumple']= $dt->format($f.$fhora);
	    		$stub->transform_BD2FW($valor, array('cumple'=>array('tipo'=>TIPO_FECHA)));
				$this->assertEquals($valor[0]['cumple']->formatFW(), $dt->format($fn), $db.$fecha[6].' (array con fecha)');
			}
    	}
    }

    /**
     * de bd a interfaz
     */
    public function testTransform_BD2User() {
    	$dbs = IgepDB::supportedDBMS();
    	$p = ConfigFramework::getNumericSeparatorsUser();
    	$f = ConfigFramework::getDateMaskUser();
   		$pd = $p['DECIMAL'];
   		$pg = $p['GROUP'];
    	foreach ($dbs as $db) {
    		$dsn_virtual = array('phptype'=>$db);
    		$fb = IgepDB::mascaraFechas($dsn_virtual);
    		$b = IgepDB::caracteresNumericos($dsn_virtual);
    		$bd = $b['DECIMAL'];
    		$bg = $b['GROUP'];
    		$v = "12{$bg}345{$bd}56";
    		$valor = IgepConexion::transform_BD2User($v,TIPO_DECIMAL,$dsn_virtual);
			$this->assertEquals($valor,	"12{$pg}345{$pd}56", $db.": convirtiendo numero");

			$v = "12{$bg}345{$bd}561";
			$valor = IgepConexion::transform_BD2User($v,TIPO_DECIMAL,$dsn_virtual,4);
			$this->assertEquals($valor,	"12{$pg}345{$pd}5610", $db.": convirtiendo numero con 3 decimales");

			$v = "12{$bg}345";
    		$valor = IgepConexion::transform_BD2User($v,TIPO_DECIMAL,$dsn_virtual);
			$this->assertEquals($valor, "12{$pg}345{$pd}00", $db.": convirtiendo numero sin decimales");

			$v = "12{$bd}345e7";
    		$valor = IgepConexion::transform_BD2User($v,TIPO_DECIMAL,$dsn_virtual);
			$this->assertEquals($valor, "123{$pg}450{$pg}000{$pd}00", $db.": convirtiendo numero con decimales y exponente");

			$v = "12{$bg}345";
    		$valor = IgepConexion::transform_BD2User($v,TIPO_ENTERO,$dsn_virtual);
			$this->assertEquals($valor, "12{$pg}345", $db.": convirtiendo entero");

			$v = "12";
    		$valor = IgepConexion::transform_BD2User($v,TIPO_ENTERO,$dsn_virtual);
			$this->assertEquals($valor, "12", $db.": convirtiendo entero sin grupos");

			$v = "12E-5";
    		$valor = IgepConexion::transform_BD2User($v,TIPO_ENTERO,$dsn_virtual);
			$this->assertEquals($valor, "0{$pd}00012", $db.": convirtiendo entero con exponente");

			$v = "-12";
    		$valor = IgepConexion::transform_BD2User($v,TIPO_ENTERO,$dsn_virtual);
			$this->assertEquals($valor, "-12", $db.": convirtiendo entero con signo -");

			$v = "+12";
    		$valor = IgepConexion::transform_BD2User($v,TIPO_ENTERO,$dsn_virtual);
			$this->assertEquals($valor, "12", $db.": convirtiendo entero con signo +");

			$v = "abc";
    		$valor = IgepConexion::transform_BD2User($v,TIPO_CARACTER,$dsn_virtual);
			$this->assertEquals($valor, "abc", $db.": convirtiendo texto sin caracteres especiales");

			$v = "ab'c";
    		$valor = IgepConexion::transform_BD2User($v,TIPO_CARACTER,$dsn_virtual);
			$this->assertEquals($valor, "ab'c", $db.": convirtiendo texto con comilla simple");

			$v = 'ab"c';
    		$valor = IgepConexion::transform_BD2User($v,TIPO_CARACTER,$dsn_virtual);
			$this->assertEquals($valor, 'ab"c', $db.": convirtiendo texto con comilla doble");

			$v = 'ab\c';
    		$valor = IgepConexion::transform_BD2User($v,TIPO_CARACTER,$dsn_virtual);
			$this->assertEquals($valor, 'ab\c', $db.": convirtiendo texto con barra invertida");

			// repito las operaciones anteriores pero ahora dentro de un array
			$datos = array(
				array('edad'=>"12{$bg}345", 'importe'=>"12{$bg}345{$bd}56", 'nom'=>"abc", 'saldo'=>"-12", 'cumple'=>'se modifica en test!!!',),
				array('edad'=>"12", 'importe'=>"12{$bg}345", 'nom'=>"ab'c", 'saldo'=>"+12",),
				);
			$tipos = array('edad'=>array('tipo'=>TIPO_ENTERO), 'importe'=>array('tipo'=>TIPO_DECIMAL, 'parteDecimal'=>2),
							'saldo'=>array('tipo'=>TIPO_ENTERO),);
			$datos_clone = $datos;
    		$valor = IgepConexion::transform_BD2User($datos_clone,$tipos,$dsn_virtual);
			$this->assertEquals($valor[0]['importe'],	"12{$pg}345{$pd}56", $db.": convirtiendo numero (array)");
			$this->assertEquals($valor[1]['importe'], "12{$pg}345{$pd}00", $db.": convirtiendo numero sin decimales (array)");
			$this->assertEquals($valor[0]['edad'], "12{$pg}345", $db.": convirtiendo entero (array)");
			$this->assertEquals($valor[1]['edad'], "12", $db.": convirtiendo entero sin grupos (array)");
			$this->assertEquals($valor[0]['saldo'], "-12", $db.": convirtiendo entero con signo - (array)");
			$this->assertEquals($valor[1]['saldo'], "12", $db.": convirtiendo entero con signo + (array)");

			// ahora el ejemplo con 4 decimales
			$datos[] = array('edad'=>"12E-5", 'importe'=>"12{$bg}345{$bd}561", 'nom'=>'ab"c',);
			$datos[] = array('edad'=>"", 'importe'=>"12{$bd}345e7", 'nom'=>'ab\c',);
			$tipos = array('importe'=>array('tipo'=>TIPO_DECIMAL, 'parteDecimal'=>4), 'edad'=>array('tipo'=>TIPO_ENTERO),);
			$datos_clone = $datos;
    		$valor = IgepConexion::transform_BD2User($datos_clone,$tipos,$dsn_virtual);
			$this->assertEquals($valor[2]['importe'],	"12{$pg}345{$pd}5610", $db.": convirtiendo numero con 3 decimales (array)");
			$this->assertEquals($valor[3]['importe'], "123{$pg}450{$pg}000{$pd}0000", $db.": convirtiendo numero con decimales y exponente (array)");
			$this->assertEquals($valor[2]['edad'], "0{$pd}00012", $db.": convirtiendo entero con exponente (array)");
			// transforma texto
			$this->assertEquals($valor[0]['nom'], "abc", $db.": convirtiendo texto (sin tipo) sin caracteres especiales (array)");
			$this->assertEquals($valor[1]['nom'], "ab'c", $db.": convirtiendo texto (sin tipo) con comilla simple (array)");
			$this->assertEquals($valor[2]['nom'], 'ab"c', $db.": convirtiendo texto (sin tipo) con comilla doble (array)");
			$this->assertEquals($valor[3]['nom'], 'ab\c', $db.": convirtiendo texto (sin tipo) con barra invertida (array)");
			$tipos = array('nom'=>array('tipo'=>TIPO_CARACTER,));
			$datos_clone = $datos;
    		$valor = IgepConexion::transform_BD2User($datos_clone,$tipos,$dsn_virtual);
			$this->assertEquals($valor[0]['nom'], "abc", $db.": convirtiendo texto (con tipo) sin caracteres especiales (array)");
			$this->assertEquals($valor[1]['nom'], "ab'c", $db.": convirtiendo texto (con tipo) con comilla simple (array)");
			$this->assertEquals($valor[2]['nom'], 'ab"c', $db.": convirtiendo texto (con tipo) con comilla doble (array)");
			$this->assertEquals($valor[3]['nom'], 'ab\c', $db.": convirtiendo texto (con tipo) con barra invertida (array)");

			// fechas, individuales y array
			// tests similares a IgepConexion->testTransform_BD2FW
			$fechas = array(
				array(0, 0, 0, 4, 15, 1990,": convirtiendo fecha correcta",),
				array(0, 0, 0, 4, 15, 1960,": convirtiendo fecha anterior epoca unix",),
				array(0, 0, 0, 4, 15, 1919,": convirtiendo fecha de principios del siglo 20",),
				array(0, 0, 0, 4, 15, 1137,": convirtiendo fecha de la epoca de Jaume I",),
				array(0, 0, 0, 4, 15, 345,": convirtiendo fecha de anyo de 3",),
				array(0, 0, 0, 4, 15, 2040,": convirtiendo fecha posterior a epoca unix",),
				array(0, 0, 0, 4, 15, 9999,": convirtiendo fecha con año maximo",),
				// tratamiento especial de los años de 2: ventana
				array(0, 0, 0, 4, 15, 85,": convirtiendo fecha de anyo de 2 de epoca unix",),
				array(0, 0, 0, 4, 15, 34,": convirtiendo fecha de anyo de 2 fuera de epoca",),
				// tratamiento especial de los años de 1: coge la decada actual
				array(0, 0, 0, 4, 15, 3,": convirtiendo fecha de anyo de 1",),
				array(10, 20, 30, 4, 15, 2003,": convirtiendo fecha con hora",),
				array(1, 1, 1, 4, 15, 2003,": convirtiendo fecha con hora inicio dia",),
				array(23, 59, 58, 4, 15, 2003,": convirtiendo fecha con hora fin dia",),
				array(47, 0, 0, 4, 15, 2003,": convirtiendo fecha con hora y más de 24 horas",),
				array(0, 300, 0, 4, 15, 2003,": convirtiendo fecha con hora y más de 60 minutos",),
				array(0, 0, 3600, 4, 15, 2003,": convirtiendo fecha con hora y más de 60 segundos",),
				array(12, 34, 56, 14, 1, 2003,": convirtiendo fecha con hora y más de 12 meses",),
				array(12, 34, 56, 5, 40, 2003,": convirtiendo fecha con hora y más de 30 dias (hasta el 40 de mayo...)",),
				);
			foreach ($fechas as $fecha) {
				$anyo = $fecha[5];
	    		if ($anyo > 9 and $anyo < 100)
	    			$anyo += ($fecha[5]<=69)? 2000: 1900;
	    		elseif ($anyo <= 9)
	    			$anyo = (int) substr(date('Y'),0,3).((string)$anyo);
				$dt = new DateTime();
				$dt->setDate($anyo,$fecha[3],$fecha[4]);
				$dt->setTime($fecha[0],$fecha[1],$fecha[2]);
				$fhora = (($fecha[0] or $fecha[1] or $fecha[2])? ' '.ConfigFramework::getTimeMask():'');

				// valor simple como fechahora
				$valor = $dt->format($fb.$fhora);
	    		$valor = IgepConexion::transform_BD2User($valor,TIPO_FECHAHORA,$dsn_virtual);
				$this->assertEquals($valor, $dt->format($f.$fhora), $db.$fecha[6].' (valor simple como fechahora)');

				// valor simple como fecha
				// no valida si hay hora
				$valor = $dt->format($fb.$fhora);
	    		$valor = IgepConexion::transform_BD2User($valor,TIPO_FECHA,$dsn_virtual);
				$this->assertEquals($valor, $dt->format($f), $db.$fecha[6].' (valor simple como fecha)');

				// valor como array fechahora
				$valor = $datos;
				$valor[0]['cumple']= $dt->format($fb.$fhora);
	    		$valor = IgepConexion::transform_BD2User($valor, array('cumple'=>array('tipo'=>TIPO_FECHAHORA)), $dsn_virtual);
				$this->assertEquals($valor[0]['cumple'], $dt->format($f.$fhora), $db.$fecha[6].' (array con fechahora)');

				// valor como array fecha
				// no valida si hay hora
				$valor = $datos;
				$valor[0]['cumple']= $dt->format($fb.$fhora);
	    		$valor = IgepConexion::transform_BD2User($valor, array('cumple'=>array('tipo'=>TIPO_FECHA)), $dsn_virtual);
				$this->assertEquals($valor[0]['cumple'], $dt->format($f), $db.$fecha[6].' (array con fecha)');
			}
    	}
	}


    /**
     * @todo Implement testCalcularSecuenciaBD().
     */
    public function testCalcularSecuenciaBD() {
        // Remove the following lines when you implement this test.
        $this->markTestIncomplete(
          'This test has not been implemented yet.'
        );
    }

    /**
     * @todo Implement testCalcularSecuencia().
     */
    public function testCalcularSecuencia() {
        // Remove the following lines when you implement this test.
        $this->markTestIncomplete(
          'This test has not been implemented yet.'
        );
    }
}

?>
